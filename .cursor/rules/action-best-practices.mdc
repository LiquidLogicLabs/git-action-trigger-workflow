---
alwaysApply: true
---

# GitHub Actions Best Practices (Node.js + Composite)

Use this as an action-agnostic playbook for building, testing, documenting, and releasing GitHub Actions.

This guidance is written for GitHub Actions, but most patterns also apply to compatible runners/forges (with small differences in APIs, permissions, and tokens).

**Sync:** This file is the canonical source. Some action repos have a copy under `.cursor/rules/action-best-practices.mdc`; when updating this file, update those copies so input/output convention (kebab-case), version/release script standard, and other guidance stay in sync.

## 1) Scope and Principles

- Prefer boring, predictable designs over clever ones.
- Make actions idempotent when possible (safe to re-run).
- Keep runtime dependencies minimal.
- Fail fast with clear error messages.
- Treat logs as a user interface: helpful, structured, and safe (no secrets).

## 2) Choose the Right Action Type

### Node.js (JavaScript/TypeScript) action

Use when you need:

- Complex logic, HTTP calls, JSON parsing
- Cross-platform behavior (Linux/Windows/macOS)
- Rich unit testing

### Composite (shell-based) action

Use when you need:

- A small wrapper around existing CLIs
- Simple orchestration of a few steps
- Minimal packaging overhead

Avoid composite actions for complex parsing/logic that becomes hard to test and maintain.

## 3) Repository Layout

### Minimal (Node.js action)

- `action.yml`
- `src/` (TypeScript source)
- `dist/` (bundled JavaScript output, committed)
- `package.json`
- `tsconfig.json`
- `README.md`
- `LICENSE` (recommended)

Optional but recommended:

- `eslint.config.mjs` (or `.eslintrc.json` for legacy)
- `jest.config.*`
- `.github/workflows/` (CI/release)
- `.devcontainer/`
- `.husky/` (pre-commit checks)

### Minimal (composite action)

- `action.yml`
- `README.md`
- scripts referenced by the action (e.g. `install.sh`)

## 4) `action.yml` Best Practices

### 4.1 Inputs

- Use `kebab-case` for input names (ecosystem convention).
- Provide examples in descriptions when the input format is non-trivial.
- Prefer explicit defaults for optional inputs.
- Consider forward-compatibility: once published, changing input names is a breaking change.

Common input conventions (recommended):

- `token`: optional override; default should come from the workflow (`${{ github.token }}` / `secrets.GITHUB_TOKEN`) when applicable.
- `platform` / `provider`: when supporting multiple forges, allow explicit override in addition to auto-detection.
- `dry-run`: for destructive actions, support a dry-run mode.
- `verbose`: for extra logs.
- `skip-certificate-check`: when the action calls external URLs (HTTP APIs, package registries, downloads) or invokes network-capable CLIs, provide an opt-in escape hatch to disable TLS certificate validation for that operation. Default should be `false`, and the action should emit a clear warning when enabled.
- Repository targeting: prefer a single `repository` in `owner/repo` form; optionally allow `owner` + `repo` inputs for convenience.

List inputs:

- If an input accepts multiple values, clearly document the format.
- Prefer accepting comma-separated lists and trimming whitespace; ignore empty entries.
- If you support globs/regex, use explicit flags like `use-regex`/`expand-packages` and document examples.

Boolean inputs:

- For JS actions, prefer `core.getBooleanInput('name')`.
- For composite actions, treat booleans as strings (`'true'/'false'`) and document that clearly.

### 4.2 Outputs

- Use `kebab-case` for output names (match inputs; ecosystem convention).
- Output names should be stable and documented.
- Outputs should be machine-friendly (JSON or simple scalars).
- If output is complex, consider emitting JSON and providing a minimal scalar for common cases.

### 4.3 Runtime

Node.js actions:

```yaml
runs:
  using: node20
  main: dist/index.js
```

Composite actions:

```yaml
runs:
  using: composite
  steps:
    - name: Do something
      shell: bash
      run: ${{ github.action_path }}/script.sh
```

### 4.4 Branding

- Add `branding` for Marketplace friendliness.
- Pick an icon/color that matches the action intent.

## 5) Implementation Patterns (Node.js)

### 5.1 Entry point

- Provide a single `run()` that:
  - reads inputs
  - validates inputs
  - executes core logic
  - sets outputs
  - handles errors once

Example skeleton:

```ts
import * as core from '@actions/core';

async function run(): Promise<void> {
  try {
    const verbose = core.getBooleanInput('verbose');
    const input = core.getInput('input', { required: true });

    core.debug(`verbose=${verbose}`);

    // ...do work...

    core.setOutput('result', 'ok');
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Unknown error';
    core.setFailed(message);
  }
}

run();
```

### 5.2 Input validation

- Validate early.
- Error messages should mention the input name and expected format.
- If an input is an enum, validate against an allow-list.

#### 5.2.1 Input config module (recommended)

- For actions with more than a few inputs or multi-platform logic, centralize input parsing and validation in a `config.ts` (or `inputs.ts`) module and export a typed `ActionInputs` object.
- Normalize booleans, defaults, and `ACTIONS_STEP_DEBUG` handling there.
- Avoid calling `core.getInput()` across multiple modules; pass the parsed config instead.
- If outputs are conditional or computed in multiple places, centralize output naming in one helper and keep log labels aligned with action.yml names.

### 5.3 Idempotency

- If the action can be safely re-run, document it.
- Avoid making irreversible changes without a clear opt-in.

### 5.4 Logging

- Use `core.info()` for normal progress.
- Use `core.warning()` for recoverable issues.
- Use `core.error()` only for actionable failures.
- Use `core.debug()` for diagnostic detail.

If you support a `verbose` input, route verbose debug logs through `core.info()` with a clear prefix so users always see them when requested.

#### Optional: centralize logging behind a logger helper

For non-trivial actions (multiple modules, HTTP calls, retries, lots of branching), consider a tiny logger wrapper (class or functions) that standardizes:

- message prefixes and formatting
- two-tier verbosity: `verbose` (operational detail) and `debugMode` (full diagnostics)
- consistent grouping (start/end), and context fields

Guidelines:

- Keep it thin: it should call `@actions/core` under the hood.
- Prefer passing `logger` into modules instead of passing `verbose` booleans everywhere.
- Support two tiers of extra logging:
  - **verbose** (`verbose` input): operational info like resolved inputs, detected platform, operations performed. Output via `core.info()` with no prefix.
  - **debug** (`ACTIONS_STEP_DEBUG` / `core.isDebug()`): full diagnostics including sanitized HTTP requests/responses and data dumps. Output via `core.info()` with a `[DEBUG]` prefix when `debugMode` is active, otherwise via `core.debug()` for framework-level visibility.
- `debugMode` implies `verbose` (debug enables both tiers).
- Detect debug mode via `core.isDebug()` or `process.env.ACTIONS_STEP_DEBUG === 'true'` -- do not add a custom `debug` input.

Recommended Logger class template:

```ts
import * as core from '@actions/core';

export class Logger {
  public readonly verbose: boolean;
  public readonly debugMode: boolean;

  constructor(verbose: boolean = false, debugMode: boolean = false) {
    this.verbose = verbose || debugMode; // debug implies verbose
    this.debugMode = debugMode;
  }

  info(message: string): void { core.info(message); }
  warning(message: string): void { core.warning(message); }
  error(message: string): void { core.error(message); }

  // Shown when verbose=true OR debug=true -- useful operational detail
  // No prefix -- appears as clean info lines
  verboseInfo(message: string): void {
    if (this.verbose) {
      core.info(message);
    }
  }

  // Shown when debug=true (ACTIONS_STEP_DEBUG) -- full diagnostic detail
  // Includes sanitized HTTP requests/responses, data dumps, etc.
  debug(message: string): void {
    if (this.debugMode) {
      core.info(`[DEBUG] ${message}`);
    } else {
      core.debug(message); // framework-level, only visible when runner debug enabled
    }
  }

  isVerbose(): boolean { return this.verbose; }
  isDebug(): boolean { return this.debugMode; }
}
```

### 5.5 Secret handling

- Mask sensitive values with `core.setSecret(value)`.
- Never print tokens, private keys, or raw authorization headers.
- Be careful when logging URLs (they can contain credentials).

### 5.6 Reuse and multi-platform design

Avoid copy/paste across actions. Prefer reuse via:

- A small shared npm package for common logic (parsing, validation, API clients, platform detection).
- A composite action or reusable workflow for orchestrating multiple steps/actions.

Guidelines:

- Keep shared libraries small, well-tested, and stable; treat them like public APIs.
- Pin shared dependencies intentionally (use semver ranges thoughtfully; consider pinning to `~` or exact versions if you need maximum reproducibility).
- Avoid having a Node.js action "call another action" at runtime. If you need composition, do it in the workflow (or in a composite action).

Org-specific (LiquidLogicLabs):

- When you need to support multiple git hosting providers (GitHub/Gitea/Bitbucket), prefer using the shared package `git-platform-detector` instead of re-implementing provider detection in each action.
- Prefer reusing existing LiquidLogicLabs actions from workflows/composites rather than duplicating their behavior.

Factory/strategy pattern (recommended for multi-platform behavior):

- Define a stable interface (e.g., `PlatformClient` / `Provider`) with a small surface area.
- Use a factory to select an implementation (`createByName`, `createByUrl`, or `createByEnv`).
- Keep platform-specific code isolated in per-provider modules; keep shared validation and error handling in one place.
- Unit test both the factory selection logic and each provider implementation independently.

## 6) Build and Packaging (Node.js)

Goals:

- The action works without `npm install` at runtime.
- The published artifact is deterministic and reviewed.

Recommended approach:

- TypeScript compile + bundle (e.g., `@vercel/ncc`) into `dist/index.js`.
- Commit `dist/`.
- Keep runtime dependencies minimal (ideally only `@actions/core` plus what is truly necessary).

### Recommended npm scripts

Treat `package.json` scripts as the contributor and CI interface. Keep script names consistent across repos.

Baseline (recommended for most Node/TS actions):

```json
{
  "scripts": {
    "build": "tsc && ncc build src/index.ts -o dist --source-map",
    "package": "npm run build",
    "lint": "eslint src/**/*.ts --no-warn-ignored",
    "format": "prettier --write .",
    "format:check": "prettier --check .",
    "typecheck": "tsc --noEmit",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "clean": "rimraf dist coverage *.tsbuildinfo"
  }
}
```

Notes:

- Only include `rimraf` if you actually need cross-platform `clean`.
- If you split test suites, add `test:unit`, `test:integration`, and/or `test:e2e` only when those exist.
- CI should generally run: `npm ci`, `npm run lint`, `npm run typecheck`, `npm test`, `npm run package`.

Optional: versioning and release helper scripts

Use npm's built-in `npm version` command with lifecycle hooks for versioning and releasing. This approach is standard, requires no third-party versioning tool, and keeps the release flow simple and predictable. Use `conventional-changelog-cli` for changelog generation from conventional commits.

**npm lifecycle hooks (add to `package.json` scripts):**

```json
"preversion": "npm test",
"version": "conventional-changelog -p angular -i CHANGELOG.md -s && git add CHANGELOG.md",
"postversion": "git push --follow-tags origin HEAD"
```

- `preversion` runs **before** the version bump — gate on passing tests.
- `version` runs **after** the bump but **before** the commit — generate changelog and stage it.
- `postversion` runs **after** the commit and tag — push everything.

**Release convenience scripts (all actions):**

```json
"release:patch": "npm version patch -m \"chore(release): %s\"",
"release:minor": "npm version minor -m \"chore(release): %s\"",
"release:major": "npm version major -m \"chore(release): %s\""
```

The `-m "chore(release): %s"` flag produces conventional commit messages (`chore(release): 2.0.3`). The `%s` is replaced by the new version.

**How `dist/` is handled for Node.js actions:**

Node.js actions need `dist/` in the release commit. Rather than amending commits or force-tagging, rely on the Husky pre-commit hook:

1. `npm version patch` bumps `package.json` and creates a commit.
2. The git pre-commit hook fires, detects the `package.json` change, runs lint, rebuilds `dist/`, and stages it via `git add dist/`.
3. The commit lands with `package.json`, `package-lock.json`, `CHANGELOG.md`, and `dist/` — all in one clean commit, one tag, no amending.

This requires the pre-commit hook to detect config/source changes and rebuild (see §3 recommended layout, `.husky/`). Example pre-commit hook:

```sh
#!/bin/sh
set -e
changed_files=$(git diff --cached --name-only --diff-filter=ACMR)
if echo "$changed_files" | grep -E '^(src/|package(-lock)?\.json|tsconfig.*\.json)' >/dev/null; then
  echo "Detected source/config changes; running lint..."
  npm run lint
  echo "Rebuilding dist..."
  npm run package
  git add dist/
fi
```

**Composite actions (no `dist/`):** The same lifecycle hooks work; the pre-commit hook simply skips the rebuild since there are no source changes to detect.

**Changelog:**

Keep `CHANGELOG.md` enabled for platform agnosticism — it works on GitHub, Gitea, Bitbucket, and offline. The `version` lifecycle hook generates it automatically from conventional commits via `conventional-changelog-cli`.

Notes:

- `npm version` also updates `package-lock.json` automatically.
- The `v` tag prefix is npm's default (`tag-version-prefix` in `.npmrc`).
- The CI release workflow should still run lint/test/package and verify `dist/` is up-to-date (see §9.3); lifecycle hooks ensure the local commit is correct, CI provides defense in depth.
- DevDependency required: `conventional-changelog-cli`.

Optional: running the release workflow locally via `act`

If your repo has a release workflow, provide a script to run it locally. This helps validate workflow wiring (permissions, job dependencies, inputs) before pushing.

```json
{
  "scripts": {
    "test:act:release:tag": "act --container-options \"--user $(id -u):$(id -g)\" --env-file .act.env --var-file .act.vars --secret-file .act.secrets -W .github/workflows/release.yml --eventpath .github/workflows/.act/event-release.json",
    "test:act:release:dispatch": "act --container-options \"--user $(id -u):$(id -g)\" --env-file .act.env --var-file .act.vars --secret-file .act.secrets -W .github/workflows/release.yml --eventpath .github/workflows/.act/event-workflow_dispatch.json"
  }
}
```

Tips:

- Keep `.github/workflows/.act/event-release.json` and `.github/workflows/.act/event-workflow_dispatch.json` in the repo (no secrets).
- For real publishing, still rely on CI; `act` is for local validation.

Example minimal scripts (if you don't use Prettier or Jest): keep the names but adjust implementations.

Example `package.json` scripts:

```json
{
  "scripts": {
    "build": "tsc && ncc build src/index.ts -o dist --source-map",
    "package": "npm run build",
    "lint": "eslint src/**/*.ts --no-warn-ignored",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "preversion": "npm test",
    "version": "conventional-changelog -p angular -i CHANGELOG.md -s && git add CHANGELOG.md",
    "postversion": "git push --follow-tags origin HEAD",
    "release:patch": "npm version patch -m \"chore(release): %s\"",
    "release:minor": "npm version minor -m \"chore(release): %s\"",
    "release:major": "npm version major -m \"chore(release): %s\""
  }
}
```

## 7) Testing Strategy

### 7.1 Unit tests (recommended)

- Test pure logic without depending on the runner environment.
- Mock `@actions/core` and any HTTP clients.

### 7.2 Integration tests (when needed)

- Exercise real parsing/IO boundaries.
- Prefer deterministic fixtures.

### 7.3 E2E tests (best for actions)

- Test the action as users run it: `uses: ./` in a workflow.
- Validate outputs and side effects.
- If external tokens/services are required, skip gracefully when not configured.

### 7.4 Local workflow testing with `nektos/act`

If you support local workflow runs, standardize on `act` so contributors can reproduce CI behavior without pushing.

Use `act` for:

- running the same build/test steps CI runs (good for catching workflow issues)
- running E2E workflows that call the action via `uses: ./`

Note: local development loops are often faster with direct scripts (`npm run lint`, `npm test`, `npm run package`). Use `act` when you want to validate workflow wiring, permissions, job ordering, caching, and action usage.

Important: `act` runs jobs in containers, which commonly run as `root`. If your repo is bind-mounted (typical), this can create root-owned files on the host (e.g., `node_modules/`, `~/.npm`, `~/.cache`) and break local development.

To avoid that, standardize on passing a host UID/GID mapping:

```bash
act --container-options "--user $(id -u):$(id -g)" -W .github/workflows/ci.yml
```

Also standardize `act` configuration via repo-local files:

- `.act.env` (non-secret environment defaults)
- `.act.vars` (workflow vars, usually empty)
- `.act.secrets` (placeholders only; do not commit real tokens)

Recommended: commit `.act.env/.act.vars/.act.secrets` and also commit `.act.env.sample/.act.vars.sample/.act.secrets.sample`.

Common `.act.env` defaults (fixes common `act` permission issues):

```dotenv
HOME=/tmp
NPM_CONFIG_CACHE=/tmp/.npm
RUNNER_TOOL_CACHE=/tmp/acttoolcache
RUNNER_TEMP=/tmp
```

Then keep `package.json` scripts simple and consistent by always referencing the files explicitly:

```bash
act --container-options "--user $(id -u):$(id -g)" --env-file .act.env --var-file .act.vars --secret-file .act.secrets -W .github/workflows/ci.yml
```

Notes:

- This works well on Linux/macOS shells. On Windows, prefer WSL or Git Bash; otherwise substitute explicit numeric IDs.
- If you already pass `--container-options` for other reasons, append the `--user ...` to the same container options string.

Recommended patterns:

- Commit reusable `event` payload files under `.github/workflows/.act/`.
- Keep secrets out of the repo; use local files or environment variables.

Common files:

- `.github/workflows/.act/event-workflow_call.json` (for `workflow_call` testing)
- `.github/workflows/.act/event-workflow_dispatch.json` (for `workflow_dispatch` testing)
- `.github/workflows/.act/event-push.json` (for `push` testing)
- `.github/workflows/.act/event-release.json` (for tag/release testing, if applicable)

Sample event payloads (minimal; adjust to match your workflows):

`event-workflow_call.json`:

```json
{
  "inputs": {
    "tag": "v1.2.3"
  }
}
```

`event-workflow_dispatch.json`:

```json
{
  "inputs": {
    "tag": "v1.2.3"
  }
}
```

`event-push.json`:

```json
{
  "ref": "refs/heads/main"
}
```

`event-release.json` (or tag push simulation):

```json
{
  "ref": "refs/tags/v1.2.3"
}
```

Recommended scripts (adjust workflow paths/job names as needed):

```json
{
  "scripts": {
    "test:act": "act --container-options \"--user $(id -u):$(id -g)\" -W .github/workflows/ci.yml",
    "test:act:verbose": "act --container-options \"--user $(id -u):$(id -g)\" -W .github/workflows/ci.yml -v",
    "test:act:ci:push": "act --container-options \"--user $(id -u):$(id -g)\" -W .github/workflows/ci.yml --eventpath .github/workflows/.act/event-push.json",
    "test:act:ci:lint": "act --container-options \"--user $(id -u):$(id -g)\" -W .github/workflows/ci.yml -j lint",
    "test:act:ci:test": "act --container-options \"--user $(id -u):$(id -g)\" -W .github/workflows/ci.yml -j test",

    "test:act:e2e": "act --container-options \"--user $(id -u):$(id -g)\" -W .github/workflows/e2e-tests.yml",
    "test:act:e2e:dispatch": "act --container-options \"--user $(id -u):$(id -g)\" -W .github/workflows/e2e-tests.yml --eventpath .github/workflows/.act/event-workflow_dispatch.json",
    "test:act:release": "act --container-options \"--user $(id -u):$(id -g)\" -W .github/workflows/release.yml --eventpath .github/workflows/.act/event-release.json"
  }
}
```

Local vars/env/secrets:

- **Secrets**: use a local `.secrets` file and pass `--secret-file .secrets`.
- **Env vars**: use `--env-file .env` (or export env vars in your shell).
- **Non-sensitive config**: prefer repository/org variables in CI; locally, pass them via env/act flags.

Examples:

```bash
act --container-options "--user $(id -u):$(id -g)" -W .github/workflows/ci.yml --secret-file .secrets --env-file .env
```

If you use job selection:

```bash
act --container-options "--user $(id -u):$(id -g)" -W .github/workflows/ci.yml -j lint --secret-file .secrets --env-file .env
```

Tips:

- If your workflows use `GITHUB_TOKEN`, you may need to provide a token to `act` via secrets.
- GitHub environment secrets cannot start with `GITHUB_`; for environment-based E2E, use `TEST_GITHUB_TOKEN` (and map to `GITHUB_TOKEN` in workflow env) to keep names consistent.
- Prefer writing workflows so they can run in forks and locally (skip external-integration tests when secrets are missing).

Optional: standardize a local runner image mapping if needed (some workflows require tools not present in the default image).

## 8) CI Workflow Patterns

### 8.1 Least privilege permissions

Set top-level permissions explicitly. Example:

```yaml
permissions:
  contents: read
```

Only elevate in the specific job/step that needs it.

### 8.2 Typical CI job order

1. Lint
2. Typecheck
3. Test
4. Build/package

### 8.3 Reusable workflows (optional)

If you have multiple entry workflows, centralize test logic in a reusable workflow.

Common org pattern:

- `test.yml` is a reusable workflow (`workflow_call`) for build + unit/integration tests; allow `workflow_dispatch` for easy manual runs.
- `ci.yml` is the entry workflow for PR/push validation and can call `test.yml` (and/or other reusable workflows) to keep steps consistent.
- `e2e-tests.yml` runs external integration tests and should be written to skip gracefully when secrets are missing.
- `release.yml` can compose them via `uses: ./.github/workflows/ci.yml` and `uses: ./.github/workflows/e2e-tests.yml` with `secrets: inherit`.

Notes:

- Secrets do **not** automatically flow into reusable workflows. If the called workflow uses `secrets.*` (e.g., `NPM_REGISTRY_TOKEN` for a private registry), the caller must pass secrets via `secrets: inherit` or by mapping only the required secrets.
- `env:` from the caller job does **not** get "passed" into a reusable workflow job; use `workflow_call` inputs (`with:`) and/or repository `vars` to pass non-secret configuration.
- Concurrency + reusable workflows: GitHub can cancel runs with an annotation like "deadlock was detected for concurrency group ... between a top level workflow and 'test'" if the caller and callee end up sharing the same concurrency group. For reusable workflows, prefer an explicit group prefix (don't rely on `github.workflow`), or omit `concurrency` in the callee and let the entry workflow own concurrency.

Example (reusable `test.yml`):

```yaml
concurrency:
  group: Test-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true
```

### 8.4 Node setup and caching

Recommended:

- Use `actions/setup-node@v4` and enable `cache: npm`.
- Use `npm ci` in CI (deterministic installs).
- If you use a private registry, write `.npmrc` in the workflow from a token secret; never commit it.

### 8.5 Concurrency

Use `concurrency` to avoid wasted CI cycles and reduce race conditions:

- For CI/validation: cancel in-progress runs per branch/PR.
- For release: consider preventing overlapping releases (often `cancel-in-progress: false`).

Recommended patterns:

- CI / validation (cancel superseded runs):

```yaml
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true
```

- If the workflow includes `schedule`, consider isolating scheduled runs:

```yaml
concurrency:
  group: ${{ github.workflow }}-${{ github.event_name == 'schedule' && 'schedule' || github.event.pull_request.number || github.ref }}
  cancel-in-progress: true
```

- Releases / publishes (do not cancel once started):

```yaml
concurrency:
  group: ${{ github.workflow }}-${{ github.event.inputs.tag || github.ref }}
  cancel-in-progress: false
```

- For `workflow_run`-driven publish workflows, key on the upstream SHA:

```yaml
concurrency:
  group: ${{ github.workflow }}-${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.event.inputs.tag || github.ref }}
  cancel-in-progress: false
```

### 8.6 Skip docs-only changes

To avoid burning CI minutes on documentation-only edits, exclude Markdown-only changes from triggering entry workflows.

Apply this to workflows with `on: push` and/or `on: pull_request` (typically `ci.yml`). Do not apply it to tag-based release workflows.

```yaml
on:
  push:
    branches: ['**']
    paths-ignore:
      - '**/*.md'
  pull_request:
    branches: ['**']
    paths-ignore:
      - '**/*.md'
```

Note: `paths-ignore` does not apply to `workflow_call`. If you use reusable workflows, the entry workflow must be the one that skips docs-only changes.

### 8.7 Matrix strategy (platforms / versions)

Use a job `strategy.matrix` when you need confidence across environments.

Recommended defaults for Node actions:

- Use an OS matrix when platform behavior matters (path handling, shell quirks, file permissions, git behavior): `ubuntu-latest`, `windows-latest`, `macos-latest`.
- Use a Node version matrix only when you explicitly support multiple runtimes. Most of our actions run as `node20`, so a Node matrix is usually unnecessary.

Example OS matrix:

```yaml
jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      - run: npm ci
      - run: npm test
```

Guidelines:

- Keep the matrix minimal (don't multiply OS x Node x extras unless you truly need it).
- If only a subset is platform-sensitive, run the full matrix on `pull_request` but a reduced set on `push`/`schedule`.
- If a job has side effects (publishing, tagging), do not run it in a matrix.

## 9) Release & Versioning

### 9.1 Tags

- Use SemVer tags: `vX.Y.Z`.
- Treat changing inputs/outputs as breaking changes (major bump).
- Consider prereleases like `v1.2.3-beta.1` for testing.

### 9.2 Release checklist

Before tagging:

- Local: `npm test`, `npm run lint`, `npm run package`
- CI: green on the commit you will tag

### 9.3 Release workflow design

Recommended release workflow properties (be consistent across repos):

- Triggers:
  - `push` on SemVer tags (`v*.*.*`) is the primary trigger.
  - Optional: `workflow_dispatch` for manual retries/testing (consider a `tag` input that lets you re-run a specific tag).
- Permissions:
  - Set top-level permissions explicitly.
  - Grant `contents: write` only in the job that creates releases or moves tags.
- Validation:
  - Re-run lint/typecheck/tests in the release workflow (defense in depth).
  - Build/package the action in the release workflow (do not rely on a prebuilt local artifact).
- Integrity:
  - Checkout with `fetch-depth: 0` if you generate changelogs from git history.
  - Assert `dist/` is up-to-date (fail if `git diff --exit-code` after `npm run package`).
  - Ensure the release is built from the tagged commit.
- Release output:
  - Generate release notes (from `CHANGELOG.md` or commit history).
  - Attach relevant artifacts when applicable.

Floating tag updates (recommended when publishing actions):

- Maintain a major floating tag (e.g., `v1`) pointing at the latest stable `v1.x.y`.
- Optional: maintain a minor floating tag (e.g., `v1.2`) if consumers pin to minor.
- Optional: maintain `latest` only if you have a clear policy for what it means.

Consistency checklist (apply the same order across repos):

1. Checkout tagged commit
2. Setup Node
3. Install dependencies (`npm ci`)
4. Lint / typecheck / test
5. Build/package (`npm run package`)
6. Verify `dist/` is clean / consistent
7. Create/update release notes
8. Update floating tags (if used)
9. Publish the release
10. Add a brief job summary (`$GITHUB_STEP_SUMMARY`) with links and version info

### 9.4 Community comparison

How this playbook's release approach compares to community and official recommendations:

**Versioning tool:** We use npm's built-in `npm version` command with lifecycle hooks (`preversion`/`version`/`postversion`) and `conventional-changelog-cli` for changelog generation. This is the most standard approach — no third-party versioning tool required. For Node.js actions, the Husky pre-commit hook handles rebuilding and staging `dist/` during the version commit (see §6).

Alternative tools (for reference, not currently used):

- **commit-and-tag-version** — Community fork of the deprecated `standard-version`; handles version bump + changelog + commit + tag in one command. Good if you prefer a single tool over lifecycle hooks.
- **release-please** (Google) — GitHub-oriented; generates PRs with version bumps and changelog; more automation, different workflow. Tightly coupled to GitHub.
- **semantic-release** — Fully automated from conventional commits; no manual bump scripts; often used with "no commit back" for npm packages.

**Where `dist/` lives:** GitHub’s [Releasing and maintaining actions](https://docs.github.com/en/actions/how-tos/create-and-publish-actions/release-and-maintain-actions) example describes a flow where the default branch stays source-only and **only tagged release commits** contain the built output (e.g. via a release-triggered workflow that builds and force-pushes tags). Our approach commits `dist/` into the version commit on the release branch and tags that commit, so the branch history includes the built artifact. Both patterns ensure the tag points at a commit that has the correct `dist/`; the difference is whether the default branch also has `dist/` in history. We choose “dist on branch” so that `@main` or `@v1` resolve to a runnable action without a separate release-asset step; the “dist only on tag” pattern keeps the default branch source-only. Either is acceptable; document the choice if you deviate.

## 10) Security Best Practices

- Minimize permissions in workflows and action usage examples.
- Pin third-party actions to a major version at minimum (or commit SHA for maximum security).
- Prefer using well-maintained actions over ad-hoc scripts for common tasks (checkout, setup runtime, caching, artifact upload, releases).
- Avoid executing remote scripts via `curl | bash` unless you verify checksums/signatures.
- Do not silently bypass TLS verification. If you must support it (self-signed corp endpoints, air-gapped mirrors), gate it behind an explicit `skip-certificate-check` input (default `false`) and warn loudly when enabled. Prefer scoping the bypass to the specific request/command rather than setting global environment flags (e.g., avoid globally setting `NODE_TLS_REJECT_UNAUTHORIZED=0`).

Scripts vs actions:

- Prefer an action when it's a standard, widely used task (less bespoke code, better ecosystem support).
- Prefer an in-repo script when the logic is org-specific and needs versioning/review alongside the action.
- If you find yourself copying the same inline `run: |` across repos, consider a reusable workflow or a small composite action.
- Validate and sanitize any user-provided inputs used in shell commands.
- Prefer `GITHUB_TOKEN` over PATs when possible.

## 11) Documentation (README)

Recommended sections:

- What it does (1-2 paragraphs)
- Quickstart usage snippet
- Inputs table (name, required, default, description)
- Outputs table
- Permissions required (explicit)
- Examples (common scenarios)
- Troubleshooting / FAQ
- Security notes (secrets, masking, permissions)
- License

Use **kebab-case** for all input and output names in README tables and in YAML examples (e.g. `skip-certificate-check`, `tag-name`). This must match `action.yml` and the GitHub Actions ecosystem convention.

When showing `uses:`, demonstrate stable pins:

```yaml
- uses: owner/repo@v1
```

## 12) Composite Action Notes

- Always set a `shell` explicitly per step.
- Use `${{ github.action_path }}` when referencing repo-local scripts.
- Quote variables in bash (`"$VAR"`) and use `set -euo pipefail` where appropriate.
- Avoid depending on tools that are not present on the runner without installing them.

## Appendix: Minimal Templates

### A) Minimal `action.yml` (Node.js)

```yaml
name: Action Name
description: Brief description
inputs:
  verbose:
    description: Enable verbose logs
    required: false
    default: 'false'
outputs:
  result:
    description: Result value
runs:
  using: node20
  main: dist/index.js
branding:
  icon: terminal
  color: blue
```

### B) Minimal `action.yml` (Composite)

```yaml
name: Action Name
description: Brief description
inputs:
  verbose:
    description: Enable verbose logs
    required: false
    default: 'false'
runs:
  using: composite
  steps:
    - name: Run script
      shell: bash
      run: |
        set -euo pipefail
        echo "hello"
```
